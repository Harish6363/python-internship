basic example



class bikes:
    def per(self):
        print("gt","650cc",15,4)
gt=bikes()
duke=bikes()
gt.per()
duke.per()


encapusulation


class bikes:
    def __init__(self,name,cc,m,cost):
        self.name=name
        self.cc=cc
        self.m=m
        self.cost=cost
    def performance(self):
        print("abt bikes",self.name,self.cc,self.m,self.cost)
gt=bikes("gt",650,5,4)
duke=bikes("duke",390,30,2)
gt.performance()
duke.performance()




class method and static method




class cars:
    wheels=4
    def __init__(self,mil,car):
        self.mil=mil
        self.car=car
    def get_mil(self):
        return c1.mil
    def set_mil(self):
        c1.mil=12
        return c1.mil
    @staticmethod
    def info():
        print("hi,shekars")
    @classmethod
    def infor(cls):
        return cls.wheels
print(cars.infor())
c1=cars(10,"bmw")
c2=cars(15,"audi")
c1.wheels=9
print(c1.mil)
print(c1.wheels)
print(c2.wheels)
print(c1.get_mil())
print(c1.set_mil())
print(c1.mil)

        
 
 
method overridding   
    


class pycharm:
    def execute(self):
        print("compiling")
        print("rnning")
class myeditor:
    def execute(self):
        print("debugging")
        print("printing error")
        print("compiling")
        print("running")
class laptop:
    def code(self,ide):
        ide.execute()
ide=myeditor()
lap1=laptop()
lap1.code(ide)



operator overloading



class student:
    def __init__(self,m1,m2):
        self.m1=m1
        self.m2=m2
        
    def __add__(self,other):
        m1=self.m1+other.m2
        m2=self.m2+other.m2
        s3=student(m1,m2)
        s3=student(m1,m2)
        return s3
    def __gt__(self,other):
        r1=self.m1+self.m2
        r2=other.m1+other.m2
        if r1>r2:
            return True
        else:
            return False
s1=student(59,65)
s2=student(67,85)
s3=s1+s2
print(s3.m1)
print(s3.m2)
if s1>s2:
    print("s1 is having more marks then s2")
else:
    print("s2 is having more than s1")




method overloading


class math:
    def add(self,a=0,b=0,c=0):
        return a+b+c
m=math()
print(m.add(1,2))
print(m.add(1,2,3))
print(m.add())
  
  



inheritance


single level inheritance



class animal:
    def sound(self):
        return "animals make different sounds"
class dog(animal):
    def s(self):
        return "dog braks" 
d=dog()
print(d.sound())
print(d.s())




multiiple inhertance




class engine:
    def engine_info(self):
        return "this is an engine"
class wheels:
    def wheels_info(self):
        return "car has 4 wheels"
class car(engine,wheels):
    def car_info(self):
        return "this a car"
c=car()
print(c.engine_info())
print(c.wheels_info())
print(c.car_info())






multi level inheritance




class animal:
    def species(self):
        return "this is an animal"
class mammal(animal):
    def category(self):
        return "this is a mammal"
class human(mammal):
    def speak(self):
        return "humnas can speak"
h=human()
print(h.species())
print(h.category())
print(h.speak())





hierarchical inheritance




class vehicle:
    def fuel_type(self):
        return "vehicles can use petrol,diesel and lpg"
class car(vehicle):
    def type(self):
        return "car is a 4-wheeler"
class bike(vehicle):
    def type(self):
        return "bike is a 2 wheeler"
c=car()
b=bike()
print(c.fuel_type())
print(b.type())
print(c.type())




hybrid inheritance





class A:
    def show_A(self):
        print("Class A")


class B(A):
    def show_B(self):
        print("Class B")


class C(A):
    def show_C(self):
        print("Class C")

class D(B, C):
    def show_D(self):
        print("Class D")


obj = D()
obj.show_A()  
obj.show_B()  
obj.show_C()  
obj.show_D()  





